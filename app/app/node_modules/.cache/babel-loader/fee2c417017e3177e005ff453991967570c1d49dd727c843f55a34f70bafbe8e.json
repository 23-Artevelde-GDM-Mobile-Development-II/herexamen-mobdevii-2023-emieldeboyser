{"ast":null,"code":"var _s = $RefreshSig$();\nimport { useCallback, useEffect, useState } from \"react\";\nimport { useAuthContext } from \"../contexts/AuthContainer\";\nimport { handleErrors } from \"../helpers/api\";\nconst useFetch = path => {\n  _s();\n  // Declare state variables to hold the fetched data and any errors\n  const [data, setData] = useState();\n  const [error, setError] = useState();\n\n  // Get the currently logged-in user from the authentication context\n  const {\n    user,\n    logout,\n    setGlobalError\n  } = useAuthContext();\n\n  // Define a function to fetch the data from the server\n  const fetchData = useCallback(() => {\n    // Create a variable to keep track of whether the component is still mounted\n    let isCurrent = true;\n    // Make a fetch request to the API endpoint with the appropriate Authorization header\n    fetch(`${process.env.REACT_APP_API_URL}${path}`, {\n      headers: {\n        Authorization: `Bearer ${user.token}`\n      }\n    })\n    // Handle any errors that may occur in the response\n    .then(handleErrors)\n    // If there are no errors, set the data state variable\n    .then(data => isCurrent && setData(data))\n    // If there is an error, set the error state variable\n    .catch(async error => {\n      console.log(error);\n      try {\n        const errormessage = await error.json().then(response => {\n          var _response$error;\n          return (_response$error = response.error) !== null && _response$error !== void 0 ? _response$error : String(error);\n        }).then(response => {\n          if (response === \"Token expired\") {\n            setGlobalError(\"Token expired\");\n            logout();\n          }\n        });\n        isCurrent && setError(errormessage);\n      } catch (ex) {\n        console.log(ex);\n      }\n    });\n\n    // Return a cleanup function that sets isCurrent to false when the component is unmounted\n    return () => isCurrent = false;\n  }, [path, logout, setGlobalError, user.token]);\n\n  // Call the fetchData function when the component mounts or when path or userId change\n  useEffect(() => {\n    return fetchData();\n  }, [fetchData]);\n\n  // Define a function to manually refresh the data\n  const invalidate = () => {\n    fetchData();\n  };\n\n  // Determine whether the data is still loading\n  const isLoading = !error && !data;\n\n  // Return an object with the data, error, isLoading, and invalidate function\n  return {\n    isLoading,\n    data,\n    error,\n    invalidate\n  };\n};\n\n// Export the useFetch hook\n_s(useFetch, \"uVIwxuaqgFUX97eajTwwKuozMRk=\", false, function () {\n  return [useAuthContext];\n});\nexport default useFetch;","map":{"version":3,"names":["useCallback","useEffect","useState","useAuthContext","handleErrors","useFetch","path","_s","data","setData","error","setError","user","logout","setGlobalError","fetchData","isCurrent","fetch","process","env","REACT_APP_API_URL","headers","Authorization","token","then","catch","console","log","errormessage","json","response","_response$error","String","ex","invalidate","isLoading"],"sources":["/Users/emieldeboyser/Documents/0_School/2022-2023/Herexamens/MOBDEV 2/newWebshop/app/app/src/hooks/useFetch.js"],"sourcesContent":["import { useCallback, useEffect, useState } from \"react\";\nimport { useAuthContext } from \"../contexts/AuthContainer\";\nimport { handleErrors } from \"../helpers/api\";\n\nconst useFetch = (path) => {\n  // Declare state variables to hold the fetched data and any errors\n  const [data, setData] = useState();\n  const [error, setError] = useState();\n\n  // Get the currently logged-in user from the authentication context\n  const { user, logout, setGlobalError } = useAuthContext();\n\n  // Define a function to fetch the data from the server\n  const fetchData = useCallback(() => {\n    // Create a variable to keep track of whether the component is still mounted\n    let isCurrent = true;\n    // Make a fetch request to the API endpoint with the appropriate Authorization header\n    fetch(`${process.env.REACT_APP_API_URL}${path}`, {\n      headers: { \n        Authorization: `Bearer ${user.token}`,\n      },\n    })\n      // Handle any errors that may occur in the response\n      .then(handleErrors)\n      // If there are no errors, set the data state variable\n      .then((data) => isCurrent && setData(data))\n      // If there is an error, set the error state variable\n      .catch(async (error) => {\n        console.log(error)\n        try{\n          \n        const errormessage = await error.json()\n        .then(response => response.error ?? String(error))\n        .then(response => {if(response === \"Token expired\")\n        {\n          setGlobalError(\"Token expired\");\n          logout();\n        }\n        \n        } )\n\n        isCurrent && setError(errormessage)\n        }\n        catch(ex) {\n          console.log(ex)\n        }\n      });\n\n    // Return a cleanup function that sets isCurrent to false when the component is unmounted\n    return () => (isCurrent = false);\n  }, [path, logout, setGlobalError, user.token]);\n \n  // Call the fetchData function when the component mounts or when path or userId change\n  useEffect(() => {\n    return fetchData();\n  }, [fetchData]);\n\n  // Define a function to manually refresh the data\n  const invalidate = () => {\n    fetchData();\n  };\n\n  // Determine whether the data is still loading\n  const isLoading = !error && !data;\n\n  // Return an object with the data, error, isLoading, and invalidate function\n  return {\n    isLoading,\n    data,\n    error,\n    invalidate,\n  };\n};\n\n// Export the useFetch hook\nexport default useFetch;\n\n"],"mappings":";AAAA,SAASA,WAAW,EAAEC,SAAS,EAAEC,QAAQ,QAAQ,OAAO;AACxD,SAASC,cAAc,QAAQ,2BAA2B;AAC1D,SAASC,YAAY,QAAQ,gBAAgB;AAE7C,MAAMC,QAAQ,GAAIC,IAAI,IAAK;EAAAC,EAAA;EACzB;EACA,MAAM,CAACC,IAAI,EAAEC,OAAO,CAAC,GAAGP,QAAQ,CAAC,CAAC;EAClC,MAAM,CAACQ,KAAK,EAAEC,QAAQ,CAAC,GAAGT,QAAQ,CAAC,CAAC;;EAEpC;EACA,MAAM;IAAEU,IAAI;IAAEC,MAAM;IAAEC;EAAe,CAAC,GAAGX,cAAc,CAAC,CAAC;;EAEzD;EACA,MAAMY,SAAS,GAAGf,WAAW,CAAC,MAAM;IAClC;IACA,IAAIgB,SAAS,GAAG,IAAI;IACpB;IACAC,KAAK,CAAE,GAAEC,OAAO,CAACC,GAAG,CAACC,iBAAkB,GAAEd,IAAK,EAAC,EAAE;MAC/Ce,OAAO,EAAE;QACPC,aAAa,EAAG,UAASV,IAAI,CAACW,KAAM;MACtC;IACF,CAAC;IACC;IAAA,CACCC,IAAI,CAACpB,YAAY;IAClB;IAAA,CACCoB,IAAI,CAAEhB,IAAI,IAAKQ,SAAS,IAAIP,OAAO,CAACD,IAAI,CAAC;IAC1C;IAAA,CACCiB,KAAK,CAAC,MAAOf,KAAK,IAAK;MACtBgB,OAAO,CAACC,GAAG,CAACjB,KAAK,CAAC;MAClB,IAAG;QAEH,MAAMkB,YAAY,GAAG,MAAMlB,KAAK,CAACmB,IAAI,CAAC,CAAC,CACtCL,IAAI,CAACM,QAAQ;UAAA,IAAAC,eAAA;UAAA,QAAAA,eAAA,GAAID,QAAQ,CAACpB,KAAK,cAAAqB,eAAA,cAAAA,eAAA,GAAIC,MAAM,CAACtB,KAAK,CAAC;QAAA,EAAC,CACjDc,IAAI,CAACM,QAAQ,IAAI;UAAC,IAAGA,QAAQ,KAAK,eAAe,EAClD;YACEhB,cAAc,CAAC,eAAe,CAAC;YAC/BD,MAAM,CAAC,CAAC;UACV;QAEA,CAAE,CAAC;QAEHG,SAAS,IAAIL,QAAQ,CAACiB,YAAY,CAAC;MACnC,CAAC,CACD,OAAMK,EAAE,EAAE;QACRP,OAAO,CAACC,GAAG,CAACM,EAAE,CAAC;MACjB;IACF,CAAC,CAAC;;IAEJ;IACA,OAAO,MAAOjB,SAAS,GAAG,KAAM;EAClC,CAAC,EAAE,CAACV,IAAI,EAAEO,MAAM,EAAEC,cAAc,EAAEF,IAAI,CAACW,KAAK,CAAC,CAAC;;EAE9C;EACAtB,SAAS,CAAC,MAAM;IACd,OAAOc,SAAS,CAAC,CAAC;EACpB,CAAC,EAAE,CAACA,SAAS,CAAC,CAAC;;EAEf;EACA,MAAMmB,UAAU,GAAGA,CAAA,KAAM;IACvBnB,SAAS,CAAC,CAAC;EACb,CAAC;;EAED;EACA,MAAMoB,SAAS,GAAG,CAACzB,KAAK,IAAI,CAACF,IAAI;;EAEjC;EACA,OAAO;IACL2B,SAAS;IACT3B,IAAI;IACJE,KAAK;IACLwB;EACF,CAAC;AACH,CAAC;;AAED;AAAA3B,EAAA,CAtEMF,QAAQ;EAAA,QAM6BF,cAAc;AAAA;AAiEzD,eAAeE,QAAQ"},"metadata":{},"sourceType":"module","externalDependencies":[]}